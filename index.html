<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D STL Measurement Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }

        #header {
            background: #2d2d44;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        h1 {
            margin-bottom: 15px;
            font-size: 24px;
        }

        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }

        button, .file-label {
            background: #4a4a6a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.3s;
        }

        button:hover, .file-label:hover {
            background: #5a5a7a;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .file-label {
            background: #2563eb;
        }

        .file-label:hover {
            background: #1d4ed8;
        }

        button.active {
            background: #16a34a;
        }

        button.clear {
            background: #dc2626;
        }

        button.clear:hover {
            background: #b91c1c;
        }

        #unitSelect {
            background: #4a4a6a;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #fileInput {
            display: none;
        }

        #info {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 8px;
        }

        #status {
            font-size: 12px;
            color: #fbbf24;
            margin-top: 5px;
        }

        #main {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        #canvasContainer {
            flex: 1;
            position: relative;
            transition: transform 0.3s ease;
        }

        #canvasContainer.minimized {
            transform: translateY(-100%);
            position: absolute;
            width: 100%;
            height: 50vh;
            z-index: 1;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #6b7280;
            pointer-events: none;
        }

        #placeholder svg {
            width: 64px;
            height: 64px;
            opacity: 0.5;
            margin-bottom: 20px;
        }

        #sidebar {
            width: 320px;
            background: #2d2d44;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #4a4a6a;
        }

        #sidebar h2 {
            margin-bottom: 15px;
            font-size: 20px;
        }

        .measurement {
            background: #3d3d5c;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .measurement-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .measurement-type {
            font-weight: 600;
            text-transform: capitalize;
        }

        .measurement-value {
            font-size: 20px;
            color: #60a5fa;
        }

        .measurement-points {
            font-size: 11px;
            color: #9ca3af;
        }

        .measurement-label {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            align-items: center;
        }

        .measurement-label input {
            flex: 1;
            background: #2d2d44;
            border: 1px solid #4a4a6a;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
        }

        .measurement-label input:focus {
            outline: none;
            border-color: #60a5fa;
        }

        .delete-btn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-btn:hover {
            background: #b91c1c;
        }

        .no-measurements {
            color: #6b7280;
            font-size: 14px;
        }

        #toggleViewBtn {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #2563eb;
            color: white;
            border: none;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        #toggleViewBtn:hover {
            background: #1d4ed8;
        }

        @media (max-width: 768px) {
            #main {
                flex-direction: column;
            }

            #canvasContainer {
                height: 40vh;
                min-height: 300px;
            }

            #canvasContainer.minimized {
                height: 0;
                min-height: 0;
                overflow: hidden;
            }

            #sidebar {
                width: 100%;
                flex: 1;
                border-left: none;
                border-top: 1px solid #4a4a6a;
            }

            #toggleViewBtn {
                display: flex;
            }

            #header {
                padding: 15px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 10px;
            }

            #controls {
                gap: 8px;
            }

            button, .file-label {
                padding: 8px 12px;
                font-size: 13px;
                gap: 6px;
            }

            button svg, .file-label svg {
                width: 16px;
                height: 16px;
            }

            #unitSelect {
                padding: 8px 12px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>3D STL Measurement Tool</h1>
            <div id="controls">
                <label class="file-label">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
                    </svg>
                    Load STL
                    <input type="file" id="fileInput" accept=".stl">
                </label>
                <button id="distanceBtn" disabled>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
                    </svg>
                    Measure Distance
                </button>
                <button id="angleBtn" disabled>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
                    </svg>
                    Measure Angle
                </button>
                <button id="clearBtn" class="clear" disabled>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Clear All
                </button>
                <select id="unitSelect">
                    <option value="mm">mm</option>
                    <option value="cm">cm</option>
                    <option value="m">m</option>
                    <option value="in">inches</option>
                </select>
            </div>
            <div id="info"></div>
            <div id="status"></div>
        </div>

        <div id="main">
            <div id="canvasContainer">
                <canvas id="canvas"></canvas>
                <div id="placeholder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
                    </svg>
                    <p style="font-size: 20px; margin-bottom: 10px;">Upload an STL file to begin</p>
                    <p style="font-size: 14px;">Drag to rotate • Scroll to zoom</p>
                </div>
            </div>

            <div id="sidebar">
                <h2>Measurements</h2>
                <div id="measurements">
                    <p class="no-measurements">No measurements yet</p>
                </div>
            </div>
        </div>

        <button id="toggleViewBtn" title="Toggle 3D View">
            <svg id="toggleIcon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 15l-6-6-6 6"/>
            </svg>
        </button>
    </div>

    <script>
        let scene, camera, renderer, model;
        let raycaster, mouse;
        let measurementMode = null;
        let selectedPoints = [];
        let pointMarkers = [];
        let lineMarkers = [];
        let measurements = [];
        let rotation = { x: 0, y: 0 };
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let currentUnit = 'mm';
        let measurementCounter = { angle: 1, distance: 1 };
        
        // Angle measurement objects
        let angleOrigin = null;
        let angleLine1 = null;
        let permanentLines = [];

        const canvas = document.getElementById('canvas');
        const fileInput = document.getElementById('fileInput');
        const distanceBtn = document.getElementById('distanceBtn');
        const angleBtn = document.getElementById('angleBtn');
        const clearBtn = document.getElementById('clearBtn');
        const unitSelect = document.getElementById('unitSelect');
        const infoDiv = document.getElementById('info');
        const statusDiv = document.getElementById('status');
        const measurementsDiv = document.getElementById('measurements');
        const placeholder = document.getElementById('placeholder');
        const toggleViewBtn = document.getElementById('toggleViewBtn');
        const toggleIcon = document.getElementById('toggleIcon');
        const canvasContainer = document.getElementById('canvasContainer');

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                canvas.clientWidth / canvas.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);

            // Grid
            const gridHelper = new THREE.GridHelper(200, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event listeners
            fileInput.addEventListener('change', handleFileUpload);
            distanceBtn.addEventListener('click', () => toggleMeasurementMode('distance'));
            angleBtn.addEventListener('click', () => toggleMeasurementMode('angle'));
            clearBtn.addEventListener('click', clearMeasurements);
            unitSelect.addEventListener('change', handleUnitChange);
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            window.addEventListener('resize', handleResize);
            toggleViewBtn.addEventListener('click', toggleCanvasView);

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                loadSTL(e.target.result);
                placeholder.style.display = 'none';
                infoDiv.textContent = `Loaded: ${file.name}`;
                distanceBtn.disabled = false;
                angleBtn.disabled = false;
            };
            reader.readAsArrayBuffer(file);
        }

        function loadSTL(arrayBuffer) {
            if (model) {
                scene.remove(model);
            }

            const geometry = parseSTL(arrayBuffer);
            geometry.computeVertexNormals();
            geometry.center();

            const material = new THREE.MeshPhongMaterial({
                color: 0x00d4ff,
                specular: 0x111111,
                shininess: 200
            });

            model = new THREE.Mesh(geometry, material);
            scene.add(model);

            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.z = maxDim * 2;
        }

        function parseSTL(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const isASCII = arrayBuffer.byteLength > 5 && 
                String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), 
                view.getUint8(3), view.getUint8(4)) === 'solid';

            return isASCII ? parseSTLASCII(arrayBuffer) : parseSTLBinary(arrayBuffer);
        }

        function parseSTLBinary(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            const triangles = view.getUint32(80, true);
            
            const vertices = [];
            const normals = [];

            for (let i = 0; i < triangles; i++) {
                const offset = 84 + i * 50;
                
                const nx = view.getFloat32(offset, true);
                const ny = view.getFloat32(offset + 4, true);
                const nz = view.getFloat32(offset + 8, true);

                for (let j = 0; j < 3; j++) {
                    const vOffset = offset + 12 + j * 12;
                    vertices.push(
                        view.getFloat32(vOffset, true),
                        view.getFloat32(vOffset + 4, true),
                        view.getFloat32(vOffset + 8, true)
                    );
                    normals.push(nx, ny, nz);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            
            return geometry;
        }

        function parseSTLASCII(arrayBuffer) {
            const text = new TextDecoder().decode(arrayBuffer);
            const vertices = [];
            
            const vertexPattern = /vertex\s+([\d.e+-]+)\s+([\d.e+-]+)\s+([\d.e+-]+)/g;
            let match;
            
            while ((match = vertexPattern.exec(text)) !== null) {
                vertices.push(
                    parseFloat(match[1]),
                    parseFloat(match[2]),
                    parseFloat(match[3])
                );
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            return geometry;
        }

        function toggleMeasurementMode(mode) {
            if (measurementMode === mode) {
                measurementMode = null;
                distanceBtn.classList.remove('active');
                angleBtn.classList.remove('active');
                statusDiv.textContent = '';
                canvas.style.cursor = 'grab';
                clearAngleTools();
            } else {
                measurementMode = mode;
                distanceBtn.classList.toggle('active', mode === 'distance');
                angleBtn.classList.toggle('active', mode === 'angle');
                canvas.style.cursor = 'crosshair';
                updateStatus();
                
                if (mode === 'distance') {
                    clearAngleTools();
                }
            }
            clearSelection();
        }

        function updateStatus() {
            if (measurementMode === 'distance') {
                statusDiv.textContent = `Click 2 points to measure distance (${selectedPoints.length}/2 selected)`;
            } else if (measurementMode === 'angle') {
                if (!angleOrigin) {
                    statusDiv.textContent = 'Click on the model to place angle origin (center point)';
                } else {
                    statusDiv.textContent = 'Click on the model to measure angle from X-axis';
                }
            }
        }

        function handleCanvasClick(event) {
            if (!measurementMode || !model) return;

            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(model);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                
                if (measurementMode === 'distance') {
                    addPointMarker(point);
                    selectedPoints.push(point);
                    updateStatus();

                    if (selectedPoints.length === 2) {
                        calculateDistance();
                        clearSelection();
                        toggleMeasurementMode('distance');
                    }
                } else if (measurementMode === 'angle') {
                    if (!angleOrigin) {
                        // First click: create origin and axes
                        createAngleTool(point);
                    } else {
                        // Second click: create measurement line and calculate angle
                        angleLine1 = createAngleLine(angleOrigin, point, 0xff0000);
                        const marker = createEndMarker(point, 0xff0000);
                        pointMarkers.push(marker);
                        finalizeAngleMeasurement(point);
                    }
                }
            }
        }

        function createAngleTool(origin) {
            angleOrigin = origin.clone();
            
            // Create origin marker (green center point)
            const originGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const originMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const originMarker = new THREE.Mesh(originGeometry, originMaterial);
            originMarker.position.copy(angleOrigin);
            scene.add(originMarker);
            pointMarkers.push(originMarker);
            
            // Create 4 reference axes (X, X', Y, Y')
            const length = 25;
            
            // X axis (positive, gray)
            const xAxisEnd = angleOrigin.clone().add(new THREE.Vector3(length, 0, 0));
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0x808080, linewidth: 2, opacity: 0.6, transparent: true });
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([angleOrigin, xAxisEnd]);
            const xAxisLine = new THREE.Line(xAxisGeometry, xAxisMaterial);
            scene.add(xAxisLine);
            lineMarkers.push(xAxisLine);
            
            // X' axis (negative, gray)
            const xAxisEndNeg = angleOrigin.clone().add(new THREE.Vector3(-length, 0, 0));
            const xAxisGeometryNeg = new THREE.BufferGeometry().setFromPoints([angleOrigin, xAxisEndNeg]);
            const xAxisLineNeg = new THREE.Line(xAxisGeometryNeg, xAxisMaterial);
            scene.add(xAxisLineNeg);
            lineMarkers.push(xAxisLineNeg);
            
            // Y axis (positive, gray)
            const yAxisEnd = angleOrigin.clone().add(new THREE.Vector3(0, length, 0));
            const yAxisGeometry = new THREE.BufferGeometry().setFromPoints([angleOrigin, yAxisEnd]);
            const yAxisLine = new THREE.Line(yAxisGeometry, xAxisMaterial);
            scene.add(yAxisLine);
            lineMarkers.push(yAxisLine);
            
            // Y' axis (negative, gray)
            const yAxisEndNeg = angleOrigin.clone().add(new THREE.Vector3(0, -length, 0));
            const yAxisGeometryNeg = new THREE.BufferGeometry().setFromPoints([angleOrigin, yAxisEndNeg]);
            const yAxisLineNeg = new THREE.Line(yAxisGeometryNeg, xAxisMaterial);
            scene.add(yAxisLineNeg);
            lineMarkers.push(yAxisLineNeg);
            
            statusDiv.textContent = 'Axes created. Click on the model to place first measurement point.';
        }

        function createAngleLine(start, end, color) {
            const material = new THREE.LineBasicMaterial({ color: color, linewidth: 3 });
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            lineMarkers.push(line);
            return line;
        }

        function createEndMarker(position, color) {
            const geometry = new THREE.SphereGeometry(0.6, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.copy(position);
            scene.add(marker);
            return marker;
        }

        function finalizeAngleMeasurement(endPoint) {
            if (!angleLine1 || !angleOrigin) return;
            
            // Project points to 2D (XY plane) for accurate angle calculation
            const origin2D = new THREE.Vector2(angleOrigin.x, angleOrigin.y);
            const end2D = new THREE.Vector2(endPoint.x, endPoint.y);
            
            // Calculate vector from origin to endpoint in 2D
            const measurementVector = new THREE.Vector2().subVectors(end2D, origin2D);
            
            // Calculate angle from positive X-axis
            // atan2 returns angle in radians from -PI to PI
            let angle = Math.atan2(measurementVector.y, measurementVector.x) * (180 / Math.PI);
            
            // Normalize to 0-360 degrees
            if (angle < 0) angle += 360;
            
            // Convert to angle <= 90 degrees
            // If angle > 90, subtract from 180 to get the complement
            let displayAngle = angle;
            if (angle > 90 && angle <= 180) {
                displayAngle = 180 - angle;
            } else if (angle > 180 && angle <= 270) {
                displayAngle = angle - 180;
            } else if (angle > 270) {
                displayAngle = 360 - angle;
            }
            
            const label = `Angle ${measurementCounter.angle}`;
            measurementCounter.angle++;

            // Store the measurement
            const measurement = {
                type: 'angle',
                label: label,
                value: displayAngle.toFixed(2),
                unit: '°',
                rawAngle: angle.toFixed(2), // Store original angle for reference
                points: [
                    { x: angleOrigin.x.toFixed(2), y: angleOrigin.y.toFixed(2), z: angleOrigin.z.toFixed(2) },
                    { x: endPoint.x.toFixed(2), y: endPoint.y.toFixed(2), z: endPoint.z.toFixed(2) }
                ],
                visualElements: {
                    origin: angleOrigin.clone(),
                    end: endPoint.clone()
                }
            };
            
            measurements.push(measurement);
            
            // Create permanent visual lines for this measurement
            createPermanentAngleVisuals(angleOrigin, endPoint, measurements.length - 1);
            
            updateMeasurementsDisplay();
            
            // Clear temporary tools
            clearSelection();
            clearAngleTools();
            toggleMeasurementMode('angle');
        }

        function createPermanentAngleVisuals(origin, end, measurementIndex) {
            // Create permanent origin marker (green center)
            const originGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const originMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const originMarker = new THREE.Mesh(originGeometry, originMaterial);
            originMarker.position.copy(origin);
            scene.add(originMarker);
            
            // Create permanent 4 reference axes (X, X', Y, Y')
            const length = 25;
            const axesMaterial = new THREE.LineBasicMaterial({ color: 0x808080, linewidth: 2, opacity: 0.6, transparent: true });
            
            // X axis
            const xAxisEnd = origin.clone().add(new THREE.Vector3(length, 0, 0));
            const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([origin, xAxisEnd]);
            const xAxisLine = new THREE.Line(xAxisGeometry, axesMaterial);
            scene.add(xAxisLine);
            
            // X' axis (negative)
            const xAxisEndNeg = origin.clone().add(new THREE.Vector3(-length, 0, 0));
            const xAxisGeometryNeg = new THREE.BufferGeometry().setFromPoints([origin, xAxisEndNeg]);
            const xAxisLineNeg = new THREE.Line(xAxisGeometryNeg, axesMaterial);
            scene.add(xAxisLineNeg);
            
            // Y axis
            const yAxisEnd = origin.clone().add(new THREE.Vector3(0, length, 0));
            const yAxisGeometry = new THREE.BufferGeometry().setFromPoints([origin, yAxisEnd]);
            const yAxisLine = new THREE.Line(yAxisGeometry, axesMaterial);
            scene.add(yAxisLine);
            
            // Y' axis (negative)
            const yAxisEndNeg = origin.clone().add(new THREE.Vector3(0, -length, 0));
            const yAxisGeometryNeg = new THREE.BufferGeometry().setFromPoints([origin, yAxisEndNeg]);
            const yAxisLineNeg = new THREE.Line(yAxisGeometryNeg, axesMaterial);
            scene.add(yAxisLineNeg);
            
            // Create permanent measurement line (red)
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([origin, end]);
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
            
            // Create permanent end marker (red)
            const endGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            const endMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const endMarker = new THREE.Mesh(endGeometry, endMaterial);
            endMarker.position.copy(end);
            scene.add(endMarker);
            
            // Store references for deletion
            permanentLines.push({
                measurementIndex: measurementIndex,
                elements: [originMarker, xAxisLine, xAxisLineNeg, yAxisLine, yAxisLineNeg, line, endMarker]
            });
        }

        function clearAngleTools() {
            angleOrigin = null;
            angleLine1 = null;
        }

        function addPointMarker(point) {
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.copy(point);
            scene.add(marker);
            pointMarkers.push(marker);

            // Add line if we have a previous point
            if (selectedPoints.length > 0) {
                addLine(selectedPoints[selectedPoints.length - 1], point);
            }
        }

        function addLine(point1, point2) {
            const material = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
            const geometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            lineMarkers.push(line);
        }

        function clearSelection() {
            selectedPoints = [];
            pointMarkers.forEach(marker => scene.remove(marker));
            pointMarkers = [];
            lineMarkers.forEach(line => scene.remove(line));
            lineMarkers = [];
        }

        function calculateDistance() {
            const distance = selectedPoints[0].distanceTo(selectedPoints[1]);
            const convertedDistance = convertUnits(distance);
            
            // Determine label based on counter
            let label;
            if (measurementCounter.distance <= 2) {
                label = `B${measurementCounter.distance}`;
            } else {
                label = String.fromCharCode(64 + measurementCounter.distance); // C, D, E, etc.
            }
            
            const measurementIndex = measurements.length;
            measurementCounter.distance++;

            measurements.push({
                type: 'distance',
                label: label,
                value: convertedDistance.toFixed(2),
                unit: currentUnit,
                rawValue: distance,
                points: selectedPoints.map(p => ({ 
                    x: p.x.toFixed(2), 
                    y: p.y.toFixed(2), 
                    z: p.z.toFixed(2) 
                }))
            });
            
            // Create permanent visual elements for distance measurement
            createPermanentDistanceVisuals(selectedPoints[0], selectedPoints[1], measurementIndex);
            
            updateMeasurementsDisplay();
        }

        function createPermanentDistanceVisuals(point1, point2, measurementIndex) {
            // Create permanent markers
            const marker1Geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const marker1Material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker1 = new THREE.Mesh(marker1Geometry, marker1Material);
            marker1.position.copy(point1);
            scene.add(marker1);
            
            const marker2Geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const marker2Material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const marker2 = new THREE.Mesh(marker2Geometry, marker2Material);
            marker2.position.copy(point2);
            scene.add(marker2);
            
            // Create permanent line
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
            
            // Store references for deletion
            permanentLines.push({
                measurementIndex: measurementIndex,
                elements: [marker1, marker2, line]
            });
        }

        function convertUnits(value) {
            // Assuming the model units are in mm
            switch(currentUnit) {
                case 'mm': return value;
                case 'cm': return value / 10;
                case 'm': return value / 1000;
                case 'in': return value / 25.4;
                default: return value;
            }
        }

        function handleUnitChange() {
            currentUnit = unitSelect.value;
            // Recalculate all distance measurements with new unit
            measurements = measurements.map(m => {
                if (m.type === 'distance' && m.rawValue !== undefined) {
                    const convertedValue = convertUnits(m.rawValue);
                    return {
                        ...m,
                        value: convertedValue.toFixed(2),
                        unit: currentUnit
                    };
                }
                return m;
            });
            updateMeasurementsDisplay();
        }

        function updateMeasurementsDisplay() {
            if (measurements.length === 0) {
                measurementsDiv.innerHTML = '<p class="no-measurements">No measurements yet</p>';
                clearBtn.disabled = true;
            } else {
                let html = measurements.map((m, i) => {
                    let displayValue = `${m.value} ${m.unit}`;
                    if (m.type === 'angle' && m.rawAngle) {
                        displayValue += ` <span style="font-size: 12px; color: #9ca3af;">(${m.rawAngle}° raw)</span>`;
                    }
                    
                    return `
                    <div class="measurement">
                        <div class="measurement-header">
                            <span class="measurement-type">${m.type}</span>
                            <span class="measurement-value">${displayValue}</span>
                        </div>
                        <div class="measurement-label">
                            <input type="text" value="${m.label}" 
                                   onchange="updateMeasurementLabel(${i}, this.value)" 
                                   placeholder="Enter label">
                            <button class="delete-btn" onclick="deleteMeasurement(${i})">Delete</button>
                        </div>
                        <div class="measurement-points">
                            ${m.points.map((p, j) => `P${j + 1}: (${p.x}, ${p.y}, ${p.z})`).join('<br>')}
                        </div>
                    </div>
                `;
                }).join('');
                
                // Add Workflow Section
                const angles = measurements.filter(m => m.type === 'angle');
                const distances = measurements.filter(m => m.type === 'distance');
                
                if (angles.length >= 2 || distances.length >= 3) {
                    html += `
                        <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #4a4a6a;">
                            <h2 style="margin-bottom: 15px; font-size: 18px;">Analysis Workflow</h2>
                            
                            <!-- Step 1: Calculate -->
                            <div id="step1" style="margin-bottom: 20px;">
                                <div style="background: #3d3d5c; padding: 12px; border-radius: 5px; margin-bottom: 10px;">
                                    <strong style="color: #60a5fa;">Step 1: Calculate Tapers</strong>
                                </div>
                                <button id="calculateTaperBtn" style="width: 100%; background: #16a34a; color: white; border: none; padding: 12px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: 600;">
                                    Calculate Tapers
                                </button>
                                <div id="taperResults" style="margin-top: 10px;"></div>
                            </div>
                            
                            <!-- Step 2: Analyze -->
                            <div id="step2" style="margin-bottom: 20px; display: none;">
                                <div style="background: #3d3d5c; padding: 12px; border-radius: 5px; margin-bottom: 10px;">
                                    <strong style="color: #60a5fa;">Step 2: Analysis</strong>
                                </div>
                                <button id="analyzeBtn" style="width: 100%; background: #2563eb; color: white; border: none; padding: 12px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: 600;">
                                    Analyze Results
                                </button>
                                <div id="analysisResults" style="margin-top: 10px;"></div>
                            </div>
                            
                            <!-- Step 3: Recommendations -->
                            <div id="step3" style="display: none;">
                                <div style="background: #3d3d5c; padding: 12px; border-radius: 5px; margin-bottom: 10px;">
                                    <strong style="color: #60a5fa;">Step 3: Recommendations</strong>
                                </div>
                                <div id="recommendations"></div>
                            </div>
                        </div>
                    `;
                }
                
                measurementsDiv.innerHTML = html;
                clearBtn.disabled = false;
                
                // Attach event listeners
                const taperBtn = document.getElementById('calculateTaperBtn');
                if (taperBtn) {
                    taperBtn.addEventListener('click', calculateTapers);
                }
                
                const analyzeBtn = document.getElementById('analyzeBtn');
                if (analyzeBtn) {
                    analyzeBtn.addEventListener('click', analyzeResults);
                }
            }
        }

        // Taper 3 lookup table
        const taper3Table = {
            2: { 3: 16, 4: 12, 5: 10, 6: 8, 7: 7, 8: 6, 9: 6, 10: 5, 11: 5, 12: 4, 13: 4 },
            3: { 3: 24, 4: 18, 5: 14, 6: 12, 7: 10, 8: 9, 9: 8, 10: 7, 11: 7, 12: 6, 13: 6 },
            4: { 3: 33, 4: 24, 5: 19, 6: 16, 7: 14, 8: 12, 9: 11, 10: 10, 11: 9, 12: 8, 13: 8 },
            5: { 3: 33, 4: 31, 5: 24, 6: 20, 7: 17, 8: 15, 9: 12, 10: 11, 11: 11, 12: 10, 13: 9 },
            6: { 3: 28, 4: 37, 5: 29, 6: 24, 7: 21, 8: 18, 9: 16, 10: 14, 11: 13, 12: 12, 13: 11 },
            7: { 3: 24, 4: 32, 5: 35, 6: 28, 7: 24, 8: 21, 9: 19, 10: 17, 11: 15, 12: 14, 13: 13 },
            8: { 3: 21, 4: 38, 5: 33, 6: 28, 7: 24, 8: 22, 9: 19, 10: 17, 11: 16, 12: 15, 13: 14 },
            9: { 3: 19, 4: 25, 5: 31, 6: 37, 7: 21, 8: 27, 9: 24, 10: 22, 11: 20, 12: 18, 13: 17 },
            10: { 3: 17, 4: 23, 5: 28, 6: 33, 7: 35, 8: 31, 9: 27, 10: 24, 11: 22, 12: 20, 13: 18 }
        };
        
        // Store calculated taper values globally
        let calculatedTapers = { taper1: null, taper2: null, taper3: null, height: null };

        function calculateTapers() {
            const angles = measurements.filter(m => m.type === 'angle');
            const distances = measurements.filter(m => m.type === 'distance');
            
            let results = '';
            let allSuccess = true;
            
            // Taper 1: Average of Angle 1 and Angle 2
            if (angles.length >= 2) {
                const angle1 = parseFloat(angles[0].value);
                const angle2 = parseFloat(angles[1].value);
                calculatedTapers.taper1 = (angle1 + angle2) / 2;
                
                results += `
                    <div class="measurement" style="background: #2d4a3e;">
                        <div class="measurement-header">
                            <span class="measurement-type">Taper 1</span>
                            <span class="measurement-value">${calculatedTapers.taper1.toFixed(2)}°</span>
                        </div>
                        <div style="font-size: 12px; color: #9ca3af; margin-top: 8px;">
                            Average of ${angles[0].label} (${angle1}°) and ${angles[1].label} (${angle2}°)
                        </div>
                    </div>
                `;
            } else {
                allSuccess = false;
            }
            
            // Taper 2 & 3: Calculation based on B1, B2, and C
            if (distances.length >= 3) {
                const b1 = parseFloat(distances[0].value);
                const b2 = parseFloat(distances[1].value);
                const c = parseFloat(distances[2].value);
                calculatedTapers.height = c;
                
                const a = (b1 - b2) / 2;
                const ratio = a / c;
                
                // Taper 2
                if (Math.abs(ratio) <= 1) {
                    const taper2Radians = Math.asin(ratio);
                    calculatedTapers.taper2 = Math.abs(taper2Radians * (180 / Math.PI));
                    
                    results += `
                        <div class="measurement" style="background: #2d4a3e;">
                            <div class="measurement-header">
                                <span class="measurement-type">Taper 2</span>
                                <span class="measurement-value">${calculatedTapers.taper2.toFixed(2)}°</span>
                            </div>
                            <div style="font-size: 12px; color: #9ca3af; margin-top: 8px;">
                                a = (${distances[0].label} - ${distances[1].label}) / 2 = ${a.toFixed(2)}<br>
                                T2 = sin⁻¹(${a.toFixed(2)} / ${distances[2].label}) = ${calculatedTapers.taper2.toFixed(2)}°
                            </div>
                        </div>
                    `;
                } else {
                    allSuccess = false;
                    results += `
                        <div class="measurement" style="background: #4a2d2d;">
                            <div class="measurement-header">
                                <span class="measurement-type">Taper 2</span>
                                <span class="measurement-value" style="color: #ef4444;">Error</span>
                            </div>
                            <div style="font-size: 12px; color: #ef4444; margin-top: 8px;">
                                Invalid calculation: a/c = ${ratio.toFixed(2)} (must be ≤ 1)
                            </div>
                        </div>
                    `;
                }
                
                // Taper 3
                const b2Rounded = Math.round(b2);
                const cRounded = Math.round(c);
                
                if (taper3Table[cRounded] && taper3Table[cRounded][b2Rounded]) {
                    calculatedTapers.taper3 = taper3Table[cRounded][b2Rounded];
                    
                    results += `
                        <div class="measurement" style="background: #2d4a3e;">
                            <div class="measurement-header">
                                <span class="measurement-type">Taper 3</span>
                                <span class="measurement-value">${calculatedTapers.taper3}°</span>
                            </div>
                            <div style="font-size: 12px; color: #9ca3af; margin-top: 8px;">
                                From table: Width (${distances[1].label}) = ${b2Rounded}mm, Height (${distances[2].label}) = ${cRounded}mm
                            </div>
                        </div>
                    `;
                } else {
                    allSuccess = false;
                    results += `
                        <div class="measurement" style="background: #4a2d2d;">
                            <div class="measurement-header">
                                <span class="measurement-type">Taper 3</span>
                                <span class="measurement-value" style="color: #ef4444;">Not Found</span>
                            </div>
                            <div style="font-size: 12px; color: #ef4444; margin-top: 8px;">
                                No table entry for Width=${b2Rounded}mm, Height=${cRounded}mm
                            </div>
                        </div>
                    `;
                }
            } else {
                allSuccess = false;
            }
            
            document.getElementById('taperResults').innerHTML = results || '<p style="color: #9ca3af; font-size: 14px;">Not enough measurements</p>';
            
            // Show Step 2 if all calculations successful
            if (allSuccess && calculatedTapers.taper1 !== null && calculatedTapers.taper2 !== null && calculatedTapers.taper3 !== null) {
                document.getElementById('step2').style.display = 'block';
            }
        }
        
        function analyzeResults() {
            const t1 = calculatedTapers.taper1;
            const t2 = calculatedTapers.taper2;
            const t3 = calculatedTapers.taper3;
            const height = calculatedTapers.height;
            const maxTaper = Math.max(t1, t2);
            
            let analysis = '';
            let recommendations = [];
            
            // Analysis conditions
            const condition1 = t1 > t3 && t2 > t3;
            const condition2 = t1 > t3 || t2 > t3;
            const condition3 = t1 <= t3 && t2 <= t3;
            const shortCrown = height < 3.5;
            const highTaperShort = maxTaper > 15 && height < 4;
            const veryHighTaper = maxTaper > 20;
            
            // Display analysis
            analysis += `
                <div style="background: #3d3d5c; padding: 15px; border-radius: 5px; margin-bottom: 10px;">
                    <div style="font-size: 13px; color: #9ca3af; margin-bottom: 10px;">
                        <strong>Values:</strong><br>
                        Taper 1: ${t1.toFixed(2)}° | Taper 2: ${t2.toFixed(2)}° | Taper 3: ${t3}°<br>
                        Height (C): ${height.toFixed(2)}mm
                    </div>
            `;
            
            if (condition1) {
                analysis += `<div style="background: #7c2d12; padding: 10px; border-radius: 4px; margin-bottom: 8px; font-size: 13px;">
                    ⚠️ <strong>Excessive taper in all directions</strong><br>
                    T1 (${t1.toFixed(2)}°) > T3 (${t3}°) AND T2 (${t2.toFixed(2)}°) > T3 (${t3}°)
                </div>`;
                recommendations.push({ severity: 'high', text: 'Add grooves and boxes' });
            } else if (condition2) {
                analysis += `<div style="background: #854d0e; padding: 10px; border-radius: 4px; margin-bottom: 8px; font-size: 13px;">
                    ⚠️ <strong>Excessive taper in one direction</strong><br>
                    ${t1 > t3 ? `T1 (${t1.toFixed(2)}°) > T3 (${t3}°)` : `T2 (${t2.toFixed(2)}°) > T3 (${t3}°)`}
                </div>`;
                recommendations.push({ severity: 'medium', text: 'Add groove only (preferably buccal or proximal)' });
            } else if (condition3) {
                analysis += `<div style="background: #065f46; padding: 10px; border-radius: 4px; margin-bottom: 8px; font-size: 13px;">
                    ✓ <strong>Conservative taper</strong><br>
                    T1 (${t1.toFixed(2)}°) ≤ T3 (${t3}°) AND T2 (${t2.toFixed(2)}°) ≤ T3 (${t3}°)
                </div>`;
                recommendations.push({ severity: 'low', text: 'No auxiliary features needed' });
            }
            
            if (shortCrown) {
                analysis += `<div style="background: #7c2d12; padding: 10px; border-radius: 4px; margin-bottom: 8px; font-size: 13px;">
                    ⚠️ <strong>Short clinical crown</strong><br>
                    Height (${height.toFixed(2)}mm) < 3.5mm
                </div>`;
                recommendations.push({ severity: 'high', text: 'Add grooves and/or boxes (short crown override)' });
            }
            
            if (highTaperShort) {
                analysis += `<div style="background: #991b1b; padding: 10px; border-radius: 4px; margin-bottom: 8px; font-size: 13px;">
                    🔴 <strong>High taper + short height</strong><br>
                    Max taper (${maxTaper.toFixed(2)}°) > 15° AND Height (${height.toFixed(2)}mm) < 4mm
                </div>`;
                recommendations.push({ severity: 'critical', text: 'Strongly recommend proximal box' });
            }
            
            if (veryHighTaper) {
                analysis += `<div style="background: #991b1b; padding: 10px; border-radius: 4px; margin-bottom: 8px; font-size: 13px;">
                    🔴 <strong>Very high taper</strong><br>
                    Max taper (${maxTaper.toFixed(2)}°) > 20°
                </div>`;
                recommendations.push({ severity: 'critical', text: 'Add both groove and box for retention rescue' });
            }
            
            analysis += `</div>`;
            
            document.getElementById('analysisResults').innerHTML = analysis;
            
            // Show recommendations
            let recsHtml = '';
            recommendations.forEach((rec, i) => {
                const bgColor = rec.severity === 'critical' ? '#991b1b' : 
                               rec.severity === 'high' ? '#7c2d12' : 
                               rec.severity === 'medium' ? '#854d0e' : '#065f46';
                recsHtml += `
                    <div style="background: ${bgColor}; padding: 15px; border-radius: 5px; margin-bottom: 10px;">
                        <div style="font-weight: 600; margin-bottom: 5px; font-size: 14px;">
                            ${rec.severity === 'critical' ? '🔴' : rec.severity === 'high' ? '⚠️' : rec.severity === 'medium' ? '⚠️' : '✓'} 
                            Recommendation ${i + 1}
                        </div>
                        <div style="font-size: 13px;">${rec.text}</div>
                    </div>
                `;
            });
            
            document.getElementById('recommendations').innerHTML = recsHtml;
            document.getElementById('step3').style.display = 'block';
        }

        function updateMeasurementLabel(index, newLabel) {
            if (measurements[index]) {
                measurements[index].label = newLabel;
            }
        }

        function deleteMeasurement(index) {
            // Remove visual elements associated with this measurement
            const visualsToRemove = permanentLines.filter(pl => pl.measurementIndex === index);
            visualsToRemove.forEach(visual => {
                visual.elements.forEach(element => scene.remove(element));
            });
            
            // Remove from permanentLines array
            permanentLines = permanentLines.filter(pl => pl.measurementIndex !== index);
            
            // Update indices for remaining measurements
            permanentLines.forEach(pl => {
                if (pl.measurementIndex > index) {
                    pl.measurementIndex--;
                }
            });
            
            // Remove measurement
            measurements.splice(index, 1);
            updateMeasurementsDisplay();
        }

        function clearMeasurements() {
            measurements = [];
            measurementCounter = { angle: 1, distance: 1 };
            
            // Remove all permanent visual elements
            permanentLines.forEach(visual => {
                visual.elements.forEach(element => scene.remove(element));
            });
            permanentLines = [];
            
            clearSelection();
            clearAngleTools();
            updateMeasurementsDisplay();
        }

        function handleMouseDown(e) {
            if (measurementMode) return;
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            canvas.style.cursor = 'grabbing';
        }

        function handleMouseMove(e) {
            if (!isDragging || measurementMode || !model) return;
            
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            rotation.y += deltaX * 0.005;
            rotation.x += deltaY * 0.005;
            
            model.rotation.y = rotation.y;
            model.rotation.x = rotation.x;
            
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function handleMouseUp() {
            isDragging = false;
            
            if (measurementMode === 'angle' && angleOrigin) {
                canvas.style.cursor = 'crosshair';
            } else if (!measurementMode) {
                canvas.style.cursor = 'grab';
            }
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY * 0.1;
            camera.position.z += delta;
            camera.position.z = Math.max(10, Math.min(500, camera.position.z));
        }

        function handleResize() {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        function toggleCanvasView() {
            canvasContainer.classList.toggle('minimized');
            const isMinimized = canvasContainer.classList.contains('minimized');
            
            // Update icon
            if (isMinimized) {
                toggleIcon.innerHTML = '<path d="M6 9l6 6 6-6"/>';
            } else {
                toggleIcon.innerHTML = '<path d="M18 15l-6-6-6 6"/>';
            }
        }

        // Touch handling for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartDistance = 0;
        let isTouchDragging = false;
        let lastTouchTime = 0;

        function handleTouchStart(e) {
            if (measurementMode) {
                // Handle measurement tap
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                const currentTime = Date.now();
                if (currentTime - lastTouchTime < 300) {
                    // Double tap detected, treat as click
                    handleCanvasClick({ clientX: touch.clientX, clientY: touch.clientY });
                }
                lastTouchTime = currentTime;
                return;
            }

            if (e.touches.length === 1) {
                // Single touch - rotation
                isTouchDragging = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Two finger - zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();

            if (!model) return;

            if (e.touches.length === 1 && isTouchDragging && !measurementMode) {
                // Rotation
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                
                rotation.y += deltaX * 0.01;
                rotation.x += deltaY * 0.01;
                
                model.rotation.y = rotation.y;
                model.rotation.x = rotation.x;
                
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const delta = (touchStartDistance - distance) * 0.5;
                camera.position.z += delta;
                camera.position.z = Math.max(10, Math.min(500, camera.position.z));
                
                touchStartDistance = distance;
            }
        }

        function handleTouchEnd(e) {
            isTouchDragging = false;
        }

        init();
    </script>
</body>
</html>